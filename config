debug = False 
# Model config
model_name = 'SSD_VGG'
model_config = {}
#model_config = {'arch': 'resnet34'}
if model_name == 'SSD_VGG':
    feature_map_sizes = [37, 19, 10, 5, 3, 1]
    scales = [0.15, 0.3 , 0.45, 0.6, 0.75, 0.9]
elif model_name == 'SSD_Resnet':
    feature_map_sizes = [38, 19, 10, 5, 3, 2]
    scales = [0.15, 0.3, 0.45, 0.6, 0.75, 0.9]
else:
    raise ValueError(model_name)
offset = 0.5
aspect_ratios = [[1, 2, 3, 1/2, 1/3]] * len(feature_map_sizes)
#aspect_ratios = [[0.807471757089097, 0.5640953254811073, 3.124674389472555, 1.1271071033550497, 1.6375677850830805, 0.3461870200732737]] * len(feature_map_sizes)
#variance = [1, 1, 1, 1]
variance = [0.1, 0.1, 0.2, 0.2]
# Data Config

dataset = 'VOC'
dataset_root_folder = 'data/voc'
dataset_version = 'VOC0712'
#dataset = 'COCO'
#dataset_root_folder = 'data/coco'
#dataset_version = '2017'

#classes = None # all classes
#classes = ['bottle', 'cup', 'wine glass', 'bowl'] # subset of classes to consider
classes = ['person']

# Training
w_loc = 1
w_classif = 1

batch_size = 8
num_epoch = 10000 # total number of epochs
image_size = 300 # image width and height
gamma = 0.9 # coef for exp. moving average calculation
mean = [0.485, 0.456, 0.406] # mean of rgb
std = [0.229, 0.224, 0.225] # std of rgb
imbalance_strategy = 'hard_negative_mining'
#imbalance_strategy = 'class_weight'
#imbalance_strategy = 'undersampling'
# for 'hard_negative_mining' and 'undersampling' imbalance_strategy
negative_per_positive = 3 
# for class_weight imbalance strategy
pos_weight = 1
neg_weight = 0.1

out_folder = 'out'

num_workers = 8 # num of workers for loading data
data_augmentation_params = {
    'patch_proba': 0,
    'min_scale': 0.1, # minimum patch width
    'max_scale': 1, # maximum patch width
    'min_aspect_ratio': 0.5, # min patch aspect ratio
    'max_aspect_ratio': 2, # max patch aspect ratio
    'nb_trials': 50, # nb of trials for patch sampling until we find a patch with at least one bbox
    'flip_proba': 0, # proba of flipping
}
train_evaluation_size = 1000
val_evaluation_size = 1000
k = 1000
lr_schedule = [
    {'iter': (0,    30*k),  'lr': 0.0001},
    {'iter': (30*k, 50*k),  'lr': 0.00001},
    {'iter': (50*k, 100*k), 'lr': 0.000001},
]
weight_decay = 5e-4

log_interval = 50
eval_interval = 50

# IOU thresholds
eval_iou_threshold = 0.5
bbox_encoding_iou_threshold = 0.5 # iou threshold used to match true bboxes to anchor boxes
nms_iou_threshold = 0.45 # iou threshold used in non maximal suppression
nms_score_threshold = 0.8 # score threshold when doing non maximal suppression
nms_topk = 200

# Visualization
pad = 30
